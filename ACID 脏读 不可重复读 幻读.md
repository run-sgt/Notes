## 通俗地解释ACID、脏读、不可重复读、幻读

### ACID 原 一 独 持

**原子性  Atomicity**

```
整个事务中的所有操作，要么全部完成，要么全部不完成，不可能停在一个中间状态。
事务在执行过程中发生错误，会被回滚到事务开始前的状态，保证事务的完整不可分割性，就像一个原子一样
例子：
    1：A与B的账中分别有1000元，
    2：他们要进行转账的交易
    3：一方交易过程出问题，回滚
```

**一致性 Consistency**

```
事务开始前与结束后，数据库的完整性约束没有被破坏
比如刚才的转账，不管成功与否，A与B的总金额是2000元是前后一致的
```

**独立性 Isolation**

```
事务的执行是互不干扰的，多用于多个事务对同一数据库同一条或多条数据进行操作时候的一种保证数据安全的隔离技术，分4中隔离级别
```

**持久性 Durability**

```
事务执行成功后，该事务对数据库的更改是持久保存在数据库中的，不会被回滚。
```

### spring（数据库）事务隔离级别分为四种（级别递减）：

```
1、Serializable （串行化）：最严格的级别，事务串行执行，资源消耗最大；

2、REPEATABLE READ（重复读） ：保证了一个事务不会修改已经由另一个事务读取但未提交（回滚）的数据。避免了“脏读取”和“不可重复读取”的情况，但不能避免“幻读”，但是带来了更多的性能损失。

3、READ COMMITTED （提交读）：大多数主流数据库的默认事务等级，保证了一个事务不会读到另一个并行事务已修改但未提交的数据，避免了“脏读取”，但不能避免“幻读”和“不可重复读取”。该级别适用于大多数系统。

4、Read Uncommitted（未提交读） ：事务中的修改，即使没有提交，其他事务也可以看得到，会导致“脏读”、“幻读”和“不可重复读取”。
```

### 脏读、不可重复读、幻读：

```
脏读：
	所谓的脏读，其实就是读到了别的事务回滚前的脏数据。比如事务B执行过程中修改了数据X，在未提交前，事务A读取了X，而事务B却回滚了，这样事务A就形成了脏读。
	也就是说，当前事务读到的数据是别的事务想要修改成为的但是没有修改成功的数据。
```

```
不可重复读：
	事务A首先读取了一条数据，然后执行逻辑的时候，事务B将这条数据改变了，然后事务A再次读取的时候，发现数据不匹配了，就是所谓的不可重复读了。
	也就是说，当前事务先进行了一次数据读取，然后再次读取到的数据是别的事务修改成功的数据，导致两次读取到的数据不匹配，也就照应了不可重复读的语义。
```

```
幻读：
	事务A首先根据条件索引得到N条数据，然后事务B改变了这N条数据之外的M条或者增添了M条符合事务A搜索条件的数据，导致事务A再次搜索发现有N+M条数据了，就产生了幻读。
	也就是说，当前事务读第一次取到的数据比后来读取到数据条目少。
```

**不可重复读和幻读比较：**

```
两者有些相似，但是前者针对的是update或delete，后者针对的insert。
```

